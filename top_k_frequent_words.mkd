# 692. Top K Frequent Words
## Description:
```
Given a non-empty list of words, return the k most frequent elements.

Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.
```
### Example 1:

##### Input:
```
 ["i", "love", "leetcode", "i", "love", "coding"], k = 2
```
##### Output:
```
 ["i", "love"]
```
##### Explanation: 
```
"i" and "love" are the two most frequent words.
    Note that "i" comes before "love" due to a lower alphabetical order.
```
### Example 2:

##### Input:
```
 ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
```
##### Output: 
```
["the", "is", "sunny", "day"]
```
##### Explanation:
```
 "the", "is", "sunny" and "day" are the four most frequent words,
    with the number of occurrence being 4, 3, 2 and 1 respectively.
```
### Note:

   1. You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
   2. Input words contain only lowercase letters.

### Follow up:

   1. Try to solve it in O(n log k) time and O(n) extra space.

```cpp
class Solution {
public:
    
    static bool comp(pair<string,int> a,pair<string,int> b)
    {
        if(a.second!=b.second) return a.second>b.second;
        else return a.first<b.first;   
    }
    
    vector<string> topKFrequent(vector<string>& words, int k) {
        vector<pair<string,int>> temp;
        int size=words.size();
        map<string,int> m;
        for(int i=size-1;i>=0;i--)
        {
            m[words[i]]++;
        }
        for(auto i=m.begin();i!=m.end();++i)
        {
            temp.push_back(*i);
        }
        sort(temp.begin(),temp.end(),comp);
        vector<string> res;

        for(auto i=temp.begin();i!=temp.end()&&k!=0;++i,--k)
        {
            /*
            if((*i).second.first<pre)
            {
                pre=(*i).second;
            }*/
            res.push_back((*i).first);
        }
        return res;
    }
};
```
***********************************
这道题仍是用map记录单词出现的次数。只不过输出是还要求对出现次数相同的单词按字母表顺序排列，这就等于要我们相对map的value排序，再对key排序。对这种情况的一般处理方法是把map放到一个vector中，然后自定义compare函数用sort来排序。最后我们在把最前面的k个单词放进另一个vector中返回即可。