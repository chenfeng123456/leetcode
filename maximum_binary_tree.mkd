Maximum Binary Tree
=========================
Description:
-----------------

 Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:

    The root is the maximum number in the array.
    The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.
    The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.

Construct the maximum tree by the given array and output the root node of this tree.

Example 1:
-------------------
Input: [3,2,1,6,0,5]
Output: return the tree root node representing the following tree:

      6
    /   \
    3     5
    \    / 
     2  0   
       \
        1

Note:
------------------
    The size of the given array will be in the range [1,1000].




```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int max(vector<int> nums,int start,int end)
    {
        if(start<0||end<0||start>end) return -1;
        if(end>=nums.size()||start>=nums.size()) return -1;
        int max=nums[start],index=start;
        for(int i=start+1;i<=end;i++)
        {
            if(nums[i]>max) 
            {
                max=nums[i];
                index=i;
            }
        }
        return index;
    }
    
    
    TreeNode* construct(vector<int>& nums,int index,int start,int end)
    {
        if(index<0||index>=nums.size()) return NULL;
        TreeNode *root;
        root=new TreeNode(nums[index]);
        //cout<<root->val<<endl;
        if(start==end) return root;
        //cout<<"********"<<endl;
        int leftRoot=max(nums,start,index-1);
        int rightRoot=max(nums,index+1,end);
        root->left=construct(nums,leftRoot,start,index-1);
        root->right=construct(nums,rightRoot,index+1,end);
        //cout<<root->val<<"*****"<<endl;
        return root;
    }
    
    
    
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        int rootIndex=max(nums,0,nums.size()-1);
        return construct(nums,rootIndex,0,nums.size()-1);
    }
};
```
**********************************************
这道题要求我们根据数组创建一个二叉树，每棵子树的根节点都是当前区间内的最大值，其左右子树的值为区间中被它分隔出的左右区间中元素的值。   
我们可以先定义一个函数，用于求给定区间中最大元素的下标。再定义一个函数用来创建二叉树。每次在创建时先找出最大元素，创建了一个后再对其分隔出的两个区间进行递归调用，知道最大元素的下标超出数组范围。
