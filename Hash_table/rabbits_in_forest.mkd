# Rabbits in Forest
## Description:
```
In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array.

Return the minimum number of rabbits that could be in the forest.
```
### Examples:
***Input***:<br> answers = [1, 1, 2]<br>
***Output***:<br> 5<br>
***Explanation***:
```
The two rabbits that answered "1" could both be the same color, say red.
The rabbit than answered "2" can't be red or the answers would be inconsistent.
Say the rabbit that answered "2" was blue.
Then there should be 2 other blue rabbits in the forest that didn't answer into the array.
The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.
```
Input: answers = [10, 10, 10]
Output: 11

***Input***:<br> answers = []<br>
***Output***: <br>0

### Note:

   1. answers will have length at most 1000.
   2. Each answers[i] will be an integer in the range [0, 999].

```cpp
    class Solution {  
        public int numRabbits(int[] answers) {  
            int res = 0;  
            int len = answers.length;  
            if (len == 0)  
                return 0;  
            Map<Integer, Integer> map = new HashMap<>();  
            for (int answer : answers) {  
                map.put(answer, map.getOrDefault(answer, 0) + 1);  
            }  
            for (Integer n : map.keySet()) {  
                int group = map.get(n) / (n + 1);  
                if (map.get(n) % (n + 1) == 0) {  
                    res += group * (n + 1);  
                } else {  
                    res += (group + 1) * (n + 1);  
                }  
            }  
            return res;  
        }  
    }  
```
***************************************
- [思路来源](https://blog.csdn.net/huanghanqian/article/details/79310354)

这里要注意几点：

1. 关键要想到所报数字不同的兔子颜色一定不同
2. 如果所报数字相同的兔子数大于报数，则这几只兔子中一定有多种颜色
3. 如果有 v 只兔子的回答是 k，(其中 v = count[k] )，那么至少有 a 只兔子也会回答 k，(已经回答了/还在森林中)，其中 a 是当 a >= v 时， k+1 的最小倍数。

