# Contiguous Array
## Description:
```
Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.
```
### Example 1:

**Input**: [0,1]
**Output**: 2
**Explanation**: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.

### Example 2:

**Input**: [0,1,0]
**Output**: 2
**Explanation**: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.

### Note: 
The length of the given binary array will not exceed 50,000.

#### my code(*Memory Limit Exceeded*)
```cpp
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        if(nums.empty()) return 0;
        int len=nums.size();
        int res=0;
        vector<vector<int>> dp(len,vector<int>(len,0)),differ(len,vector<int>(len,0));
        for(int i=len-1;i>=0;i--)
        {
            dp[i][i]=0;
            differ[i][i]=nums[i]==0?1:-1;
            if(i<len-1)
            {
                if(nums[i]!=nums[i+1])
                {
                    dp[i][i+1]=1;
                    differ[i][i+1]=0;
                    res=max(res,2);
                }
                else differ[i][i+1]=nums[i]==0?2:-2;
            }
            for(int j=i+2;j<len;j++)
            {
                if(nums[i]!=nums[j]) differ[i][j]=differ[i+1][j-1];
                else if(nums[i]==0) differ[i][j]=differ[i+1][j-1]+2;
                else if(nums[i]==1) differ[i][j]=differ[i+1][j-1]-2;
                
                if((j-i)%2==0)
                {
                    dp[i][j]=0;
                } 
                else 
                {
                    if(differ[i][j]==0)
                    {
                        dp[i][j]=1;
                        res=max(res,j-i+1);
                    }
                }
                
                
            }
        }
        /*for(int i=0;i<len;i++)
        {
            cout<<"start from "<<i<<" to:"<<endl;
            for(int j=0;j<len;j++)
            {
                cout<<"                 "<<j<<": "<<differ[i][j]<<endl;
            }
        }*/
        return res;
    }
};
```

#### my modified code(*Time Limit Exceeded*)
```cpp
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        if(nums.empty()) return 0;
        int len=nums.size();
        int res=0;
        vector<int> differ(len,0);
        for(int i=len-1;i>=0;i--)
        {
            differ[i]=nums[i]==0?1:-1;
            if(i<len-1)
            {
                if(nums[i]!=nums[i+1])
                {
                    differ[i+1]=0;
                    res=max(res,2);
                }
                else differ[i+1]=nums[i]==0?2:-2;
            }
            for(int j=i+2;j<len;j++)
            {
                if(nums[j]==0) differ[j]=differ[j-1]+1;
                else if(nums[j]==1) differ[j]=differ[j-1]-1;
                 
                if((j-i)%2==1) 
                {
                    if(differ[j]==0)
                    {
                        res=max(res,j-i+1);
                    }
                }
                
                
            }
        }
        /*for(int i=0;i<len;i++)
        {
            cout<<"start from "<<i<<" to:"<<endl;
            for(int j=0;j<len;j++)
            {
                cout<<"                 "<<j<<": "<<differ[i][j]<<endl;
            }
        }*/
        return res;
    }
};
```

#### nice code(*Accepted*)
```cpp
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int res = 0, n = nums.size(), sum = 0;
        unordered_map<int, int> m{{0, -1}};
        for (int i = 0; i < n; ++i) {
            sum += (nums[i] == 1) ? 1 : -1;
            if (m.count(sum)) {
                res = max(res, i - m[sum]);
            } else {
                m[sum] = i;
            }
        }
        return res;
    }
};
```
****************************************
- [思路来源](https://www.cnblogs.com/grandyang/p/6529857.html)

一开始还是想着用动态规划做（my code和my modified code），结果都失败了，于是从网上看了看，发现一个很巧妙的方法。

我们遇1加1，遇0减1，用map记录到当前元素时的累加和以及其坐标。若我们发现这个累加和出现过，则从上一次这个累加和出现的位置***的下一个***到当前位置中的0和1是相等的，这也是为什么初始时我们要把坐标置为-1。