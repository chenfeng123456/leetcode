# *Validate Binary Search Tree
## Description
```
Given a binary tree, determine if it is a valid binary search tree (BST).
```
Assume a BST is defined as follows:

   - The left subtree of a node contains only nodes with keys less than the node's key.
   - The right subtree of a node contains only nodes with keys greater than the node's key.
   - Both the left and right subtrees must also be binary search trees.

### Example 1:
```
Input:
    2
   / \
  1   3
Output: true
```
### Example 2:
```
    5
   / \
  1   4
     / \
    3   6
Output: false
Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value
             is 5 but its right child's value is 4.
```
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool judge(TreeNode* root, bool left, long long minPre, long long maxPre)
    {
        if(root==NULL) return true;
        if(root->val < maxPre && root->val > minPre)
            return judge(root->left, true, minPre, root->val)&&judge(root->right, false, root->val, maxPre);
        else return false;
    }
    
    
    
    bool isValidBST(TreeNode* root) {
        if(root == NULL) return true;
        return judge(root->left, true, LONG_MIN, root->val) && judge(root->right, false, root->val, LONG_MAX);
    }
};
```
**************************************
- beat 100%

这道题代码不长，但十分“绕”。想出这个算法并验证其正确性还是挺麻烦的。

这道题最麻烦的地方在于如何验证该节点的值是否对其上所有父节点都满足条件。事实上这里要用到递推的思想来简化问题。

我们以BST中的某一节点的左孩子为例，左孩子必须要小于父节点的值。但我们知道，父节点上面还有父节点，而这些父节点有的比左孩子大，有的它小，我们需要找到一种算法来判断这一点。那么这里我们用递推的思路：既然我们已经访问到了该节点，那么说明其上的所有节点都是满足BST要求的，我们可以根据这一条件来求解。

- 我们先求上限：
    - 对于左孩子（下称当前节点或A节点以示区分）而言，它首先必须小于其父节点B的值，同时：
        - 若B又是另一节点C的左孩子，那么A必须还要小于C。但我们又知道，B一定小于C，所以小于B就一定小于C。
            - 如果C又是其父节点的左孩子，由上可知仍然令A小于B就足够了。
            - 如果C是其父节点D的右孩子，那么我们BST特性可知，此时A应大于D，而这里我们找的是上限，故可直接略去D，在往上找，并且类似的，只要遇到右孩子的父节点我们都可忽略。
         - 若B是C的右孩子，以及A与D之间应怎么处理，都可参照上面的做法。
         
    所以我们找出了规律：对于左孩子A而言，我们往上遍历，凡是遇到右孩子的父节点都可忽略，凡是遇到左孩子父节点只需令A小于B即可。
    
    由此我们得出结论：对于二叉搜索树中的任意节点的左孩子而言，其上限值就是它的父节点的值。

- 再来求下限：
    - 仍以左孩子A为例，我们往上遍历，这一次忽略所有的左孩子的父节点，而对于其中的某个右孩子的父节点E而言，由于A属于其右子树，那么A的值一定要比E大。同样的，对于E之上的某一右孩子的父节点F，A一定要比F大，又因为E的值也比F大，那么我们只需要令A大于E就够了。
    
    于是在此得到结论：对于二叉搜索树中的任意节点的左孩子而言，其下限值就是里它最近的右孩子的父节点的值。
    
事实上，根据下限的结论，我们可以将上限的结论改写为：对于二叉搜索树中的任意节点的左孩子而言，其下限值就是里它最近的左孩子的父节点的值，只不过我们已经预设了当前节点是其上一节点的左孩子，所以离他最近的左孩子的父节点就是其父节点。

***实际上，不管怎么说，用语言表达出来总感觉很抽象，最重要的还是要在纸上动手画一画。***



