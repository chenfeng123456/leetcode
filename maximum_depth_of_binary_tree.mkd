# Maximum Depth of Binary Tree
## Description:
```
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
```
**Note**: A leaf is a node with no children.

### Example:
```
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

return its depth = 3.
```
#### my code(*Accepted*)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        global res
        res = 0
        
        def traverse(root, depth):
            global res
            if root == None:
                res = max(res, depth-1)
                return
            traverse(root.left, depth+1)
            traverse(root.right, depth+1)
        
        traverse(root, 1)
        return res
```
#### nice code(*Accepted*)
```python
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root is None:
        	return 0
        queue = []
       	queue.append(root)
       	depth = 1
       	a = len(queue)
       	while len(queue) > 0:
       		if a == 0:
       			a = len(queue)
       			depth += 1
       		curr = queue.pop(0)
       		a -= 1
       		if curr.left is not None:
       			queue.append(curr.left)
       		if curr.right is not None:
       			queue.append(curr.right)
       	return depth
```
********************************************
这道题用递归的做法没什么好说的，来看看别人是怎么用迭代做的。

我们建立一个队列，每次把队头的元素删除，同时把它的两个子节点加进来。当我们把某一层的节点都删除后，队列里剩余的就都是下一层的节点了。我们用一个变量a来记录这一层的节点数。所以当a为0的时候，就代表我们已经遍历过一层了，此时depth加1。而当队列的长度为0时，就说明这一层之后没有节点了，也就是说整个二叉树已经遍历完毕了，此时我们即可返回深度。