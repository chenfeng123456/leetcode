Min Cost Climbing Stairs
=================
Description:
----------------
 On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).

Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.

Example 1:
-------------
Input: cost = [10, 15, 20]<br>
Output: 15<br>
Explanation: Cheapest is start on cost[1], pay that cost and go to the top.<br>

Example 2:
-----------------
Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>
Output: 6<br>
Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].<br>

Note:
----------------
    1.cost will have a length in the range [2, 1000].
    2.Every cost[i] will be an integer in the range [0, 999].





***code 1(Time Limit Exceeded):***

```c
class Solution {
public:
    int minCost(vector<int>& cost,int index)
    {
        if(index==cost.size()) return 0;
        else if(index==cost.size()-1) return(cost[index]);
        else
        {
            int sum=0;
            int x=minCost(cost,index+1);
            int y=minCost(cost,index+2);
            sum=cost[index]+(x>y?y:x);
            return sum;
        }
    }
    
    
    int minCostClimbingStairs(vector<int>& cost) {
        int x=minCost(cost,0);
        int y=minCost(cost,1);
        return(x>y?y:x);
    }
};
```            
<br>

***code 2(Accepted):***

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int min[10001]={0};
        min[0]=cost[0];
        min[1]=cost[1];
        int sum=0,i;
        for(i=2;i<cost.size();i++)
        {
            min[i]=cost[i]+(min[i-1]>min[i-2]?min[i-2]:min[i-1]);
            cout<<min[i]<<' '<<i<<endl;
        }
        min[i]=min[i-1]>min[i-2]?min[i-2]:min[i-1];
        return min[cost.size()];
    }
};
```
***********************************
这题最开始是用的递归来解答的，结果发现是Time Limited Exceed，后来去网上一查，发现是用动态规划来做的。其实动态规划跟递归的思想都差不多，我们都先假设在i之前的工作都已经做好，然后根据应完成的来推下一步。只不过此处用动态规划是定义一个数组或一个变量，而递归是反复调用一个函数。由于反复调用函数会造成时间上的浪费，所以动态规划要更为省时间些。<br>
回到题目上来，根据题设，我们定义一个长度为1001的数组min，设min[i]表示到第i级阶梯时最少的花费。由于每次可以跨一步或两步，所以第i步一定是由第i-1步或第
i-2步上来的。那么min[i]的最小值就是min[i-1]和min[i-2]中较小者与nums[i]的和。这样就列出了递推关系式。<br>
再来看一下初始条件，由题意知，在最开始时，我们可以先上到第一级阶梯或直接跨到第二级，所以min[0]和min[1]的值就为nums[0]和nums[1].<br>
最后来分析以下终止条件。当我们到最后一级或倒数第二级时都可以结束爬楼，所以我们最终要判断的是min[nums.size()-1]和min[nums.size()-2]的大小，而不能直接将循环结束后数组的最后一个元素输出（只能输出min[nums.size()-1])或把循环条件设为i<=nums.size()（会导致数组越界）。应当在循环正常结束后单独设一个变量用于存储最终结果，并返回。
