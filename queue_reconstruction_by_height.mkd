# Queue Reconstruction by Height
## Description:
```
Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.
```
### Note:
The number of people is less than 1,100.

### Example

***Input***

[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

***Output***:

[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
#### code 1:
```cpp
class Solution {
public:
    vector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) {
        sort(people.begin(), people.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            return a.first > b.first || (a.first == b.first && a.second < b.second);
        });
        vector<pair<int, int>> res;
        for (auto a : people) {
            res.insert(res.begin() + a.second, a);
        }
        return res;
    }
};
```

#### code2:
```cpp
class Solution {
public:
    vector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) {
        sort(people.begin(), people.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            return a.first > b.first || (a.first == b.first && a.second < b.second);
        });
        for (int i = 1; i < people.size(); ++i) {
            int cnt = 0;
            for (int j = 0; j < i; ++j) {
                if (cnt == people[i].second) {
                    pair<int, int> t = people[i];
                    for (int k = i - 1; k >= j; --k) {
                        people[k + 1] = people[k];
                    }
                    people[j] = t;
                    break;
                }
                if (people[j].first >= people[i].first) ++cnt;
            }
        }
        return people;
    }
};
```


***********************************
- [思路来源](https://www.cnblogs.com/grandyang/p/5928417.html)

以上两份代码，第一份很巧妙，也很简洁，但要用到额外的空间；第二分则不需要。由于网上关于第二份代码的思路讲解的很清晰而第一份则只是稍微一提，我们这里主要讲一讲第一个的思路。

关键有以下两点：
1. 由于second表示前面不比自己矮的人的个数，所以身高相同时second大者排在后面；
2. 比自己矮的人插到前面是不会影响到自己second的值的；

以上2实现然的，1也很容易证明：如果second大的人站前面，那么与它身高相同且second小的人的second值就是前者的second值加上他们之间身高大于他们的人数，显然与假设矛盾。

由此我们可以先给数组排序：身高高的排前面，如果身高相同，则第二个数小的排前面。然后我们再建立一个新的数组，从第一个开始逐个向里面插入。插入时的位置为数组的起始位置加上该元素的second值，这是为了给比他高的人留出位置来。

这里我们自然会问如果有两个second相同的人怎么办？注意我们这里是按照身高从高到矮的顺序进行插入，而前面也说过，身高比自己矮的人插到前面不影响自己的second值。我们可以相见，当有多个second值相同的人时，矮的人后插入，而他会把本来在这个位置的挤到后面去，但这并不会影响到后者的second值。

由此算法的可行性得证。