# 36. Valid Sudoku
## Description:
```
Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

    Each row must contain the digits 1-9 without repetition.
    Each column must contain the digits 1-9 without repetition.
    Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.


A partially filled sudoku which is valid.

The Sudoku board could be partially filled, where empty cells are filled with the character '.'.
```
### Example 1:
```
Input:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: true
```
### Example 2:
```
Input:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being 
    modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
```
### Note:

   - A Sudoku board (partially filled) could be valid but is not necessarily solvable.
   - Only the filled cells need to be validated according to the mentioned rules.
   - The given board contain only digits 1-9 and the character '.'.
   - The given board size is always 9x9.

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        for(int i=0;i<9;i++)
        {
            map<char,bool> row,col;
            for(int j=0;j<9;j++)
            {
                if(board[i][j]!='.')
                {
                    if(row[board[i][j]]) return false;
                    row[board[i][j]]=true;
                }
                if(board[j][i]!='.')
                {
                    if(col[board[j][i]]) return false;
                    col[board[j][i]]=true;
                }          
            }
        }
        for(int i=0;i<9;i+=3)
        {
            for(int j=0;j<9;j+=3)
            {
                map<char,bool> m;
                for(int t=i;t<i+3;t++)
                {
                    for(int h=j;h<j+3;h++)
                    {
                        if(board[t][h]=='.') continue;
                        if(m[board[t][h]]) return false;
                        m[board[t][h]]=true;
                    }
                }
            }
        }
        return true;
    }
};
```
*********************************************
乍一看是一道十分吓人的题，其实归结起来很简单，就是要我们验证给定的矩阵中每一行、每一列以及每一个3*3的小矩阵中是否有重复的数字。

这题可以用vector也可以用map做。这里我用的是map。先用两个<char,bool\>型的map：row、col来记录每一行字符是否已出现，若该字符在map中的对应值为true而当前字符又刚好是它，则直接返回false。然后再用一个map记录每个3*3的小矩阵中是否有重复数字，方法一样。**注意这里的小矩阵相互之间不重叠，即总共只有9个小矩阵**。