# 331. Verify Preorder Serialization of a Binary Tree
## Description:
```
One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.

     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #

For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where # represents a null node.

Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.

Each comma separated value in the string must be either an integer or a character '#' representing null pointer.

You may assume that the input format is always valid, for example it could never contain two consecutive commas such as "1,,3".
```
### Example 1:
```
Input: "9,3,4,#,#,1,#,#,2,#,6,#,#"
Output: true
```
### Example 2:
```
Input: "1,#"
Output: false
```
### Example 3:
```
Input: "9,#,#,1"
Output: false
```
```cpp
class Solution {
public:
    int index;
    int size;
    
    
    bool judge(string &preorder,int i)
    {
        if(i>=preorder.size()) return false;
        if(preorder[i]>='0'&&preorder[i]<='9')
        {
            while(preorder[i]>='0'&&preorder[i]<='9')
            {
                preorder[i]='*';
                if((++i)>=preorder.size()) return false;
            }
            index=i-1;
            i=index;
        }
        else if(preorder[i]=='#') 
        {
            index=i;
            preorder[i]='*';
            return true;
        }
        //preorder[i]='*';
        bool right;
        bool left=judge(preorder,index+2);
        if(left) right=judge(preorder,index+2);
        else return false;
        return right;
    }
    
    
    
    
    bool isValidSerialization(string preorder) {
        if(!judge(preorder,0)) {cout<<preorder<<endl;return false;}
        else 
        {
            cout<<preorder<<endl;
            for(int i=0;i<preorder.size();i++)
                if(preorder[i]!=','&&preorder[i]!='*') return false;
            return true;
        }
    }
};
```
*************************************
对这道题，我们可以这样判断：对preorder中的某一个值来说，它及它以后的值可以构成一个二叉树当且仅当它的左子树满足且右子树满足。这样我们就可以用递归来做。同时为了防止重复访问同一个数，在访问完之后将其标志为‘*’。

由于这是对二叉树的输出，所以最后一定是以空节点为结束。如果说我们一直遍历到了字符串的最后递归还没有终止，那说明这个序列一定是错的。同样，如果整个递归结束了却还有数没有被访问到，那么这个序列也一定是错的。如果上面的两个条件都没有被触发且程序成功进行到了最后，说明这个序列是正确的。