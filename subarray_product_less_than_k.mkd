Subarray Product Less Than K
============================
Description:
-----------------------------
Your are given an array of positive integers nums.

Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.

Example 1:
-----------------------
Input: nums = [10, 5, 2, 6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.

Note:
----------------------
0 < nums.length <= 50000.
0 < nums[i] < 1000.
0 <= k < 10^6.







```cpp
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int ans=0,left=0,right=0,pro=1;
        for(;right<nums.size();right++)
        {
            pro*=nums[right];
            while(pro>=k&&left<=right) 
                pro/=nums[left++];
            if(left<=right) ans+=right-left+1;
            else right=left-1;
        }
        return ans;
    }
};
```
这题本来向直接暴力解决的，但是leetcode不答应。试了半天最后还是到网上看了一下别人的思路，受了启发，回来完成了这道题。<br>
这题我们定义两个变量left、right，分别表示当前“窗口”的最左端和最右端。在定义一个变量pro用于储存从left到right所有元素的乘积。若此乘积小于k，则给所要返回的答案ans加right-left+1。这里right-left+1表示从left到right这个范围的数组中一right为结尾的所有子数组的数量。若乘积大于k，则令pro除以left对应的元素，并令left右移一位，循环往复直至pro小于k为止。如此我们便可计算出所有的情况。<br>
***这里要特别注意的一点是需考虑k=0的存在。***我自己的方法是如果当left和right重合后pro仍小于k，那么我们直接跳出循环开始后面的扫描。**注意跳出循环后对left和right的处理，跳出时left应该是在right右边一位的但是由于外层for循环还会对right加1，所以不能令right等于left。**<br>
事实上我这样做复杂了，成功后我又取看了一眼网上的答案，发现它们是只要k等于0就直接返回0……
