Count and Say
============
Description:
----------------
The count-and-say sequence is the sequence of integers with the first five terms as following:

1.     1
2.     11
3.     21
4.     1211
5.     111221

1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.

Given an integer n, generate the nth term of the count-and-say sequence.

Note:
--------------
Each term of the sequence of integers will be represented as a string. 

Example 1:
----------
Input: 1<br>
Output: "1"<br>

Example 2:
------------
Input: 4<br>
Output: "1211"<br>


***my code:***
```c
char* countAndSay(int n) {
    if(n==1)
    {
        char *answer=(char *)malloc(sizeof(char));
        answer[0]='1';
        return answer;
    }
    /*else if(n==2)
    {
            char *answer=(char *)malloc(sizeof(char)*2);
            answer[0]='1';
            answer[1]='1';
            return answer;
    }*/ //这段其实可以不要
    else
    {
        char *pre=countAndSay(n-1);
        int size=strlen(pre);
        int *preN=(int *)malloc(2*size*sizeof(int));
        int j=-2;
        for(int i=0;i<size;)
        {
            j=j+2;
            preN[j+1]=pre[i]-'1'+1;
            preN[j]=0;
            while(pre[i]==preN[j+1]-1+'1'&&i<size)
            {
                preN[j]++;
                i++;
            }
        }
        char *answer=(char *)malloc(sizeof(char)*2*size);
        int k=0;
        for(int i=0;k<j+1;i=i+2)
        {
            if(preN[i]==0) continue;
            answer[k]=preN[i]-1+'1';
            answer[k+1]=preN[i+1]-1+'1';
            k=k+2;
        }
        answer[k]='\0';
        free(preN);
        free(pre);
        return answer;
    }
}

```

***modified code:***
```c
char* countAndSay(int n) {
    if(n==1)
    {
        char *answer=(char *)calloc(2, sizeof(char));
        answer[0]='1';
        return answer;
    }
    
    else
    {
        char *pre=countAndSay(n-1);
        int size=strlen(pre);
        int *preN=(int *)calloc(2*size, sizeof(int));
        int j=-2;
        for(int i=0;i<size;)
        {
            j=j+2;
            preN[j+1]=pre[i]-'1'+1;
            preN[j]=0;
            while(pre[i]==preN[j+1]-1+'1'&&i<size)
            {
                preN[j]++;
                i++;
            }
        }
        char *answer=(char *)calloc(2*size, sizeof(char));
        int k=0;
        for(int i=0;k<j+1;i=i+2)
        {
            if(preN[i]==0) continue;
            answer[k]=preN[i]-1+'1';
            answer[k+1]=preN[i+1]-1+'1';
            k=k+2;
        }
        answer[k]='\0';
        free(preN);
        free(pre);
        return answer;
    }
}
```
上述的两份代码关键的区别就在于一个用malloc函数分配内存（Wrong Answer），一个用的是calloc（Accepted）。所以我们这里主要归纳以下两者的不同之处：<br>
1.calloc函数会对所申请的空间初始化（全部初始化为0），而malloc则不会。也就是说我们用malloc申请了一片空间之后，里面的数据是无法预料的，即垃圾数据————这也就解释了为什么我的代码每次提交后错误的结果总是不同。<br>
2.malloc函数的效率高于calloc函数。虽然calloc函数用起来更加安全，但它毕竟多了一个对内存写零的操作，其效率自然会低一些。而很多时候我们并不需要这个操作，这也就是为什么我们作为初学者，在实际编写代码的过程中，会更多地见到malloc函数而非calloc。<br>
3.在使用时，malloc有一个参数，而calloc有两个。malloc的参数为所申请内存的大小，calloc的参数为元素的数目和每个元素的大小（二者的乘积即为分配内存的大小）。<br>
以上就是我们在使用两个函数时应当注意的几个不同点。<br>
参考资料：<br>[realloc、malloc、以及calloc函数的区别](http://blog.csdn.net/u014170207/article/details/53126340)<br>
         [malloc 和alloc及calloc的区别](http://blog.csdn.net/woxincd/article/details/8279775)<br>
         [百度百科](https://baike.baidu.com/item/calloc/10931444?fr=aladdin)<br>
         
另外的收获————sizeof：<br>
1.sizeof是运算符而非函数。<br>
2.sizeof操作符不能返回动态地被分派了的数组或外部的数组的尺寸。如果用sizeof计算一段用malloc申请的内存，返回值永远是对应指针变量的大小（如本题中是char\*，大小为8）。
详情参考[百度百科](https://baike.baidu.com/item/sizeof#2)
