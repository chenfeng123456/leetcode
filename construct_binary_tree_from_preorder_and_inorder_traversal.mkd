# Construct Binary Tree from Preorder and Inorder Traversal
## Description:
```
Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.
```
### For example
```
given 

preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]

Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7

```
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void construct(TreeNode *&root,vector<int>& preorder,int prestart,int preend,vector<int>& inorder,int instart,int inend)
    {
        if(instart>inend) return;
        root=new TreeNode(preorder[prestart]);
        int i;
        for(i=instart;i<=inend;i++)
        {
            if(inorder[i]==root->val) break;
        }
        construct(root->left,preorder,prestart+1,prestart+i-instart,inorder,instart,i-1);
        construct(root->right,preorder,prestart+i-instart+1,preend,inorder,i+1,inend);//cout<<root->val<<endl;
    }
    
    
    
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        TreeNode *root=NULL;
        if(preorder.empty()) return root;
        construct(root,preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);
        return root;
    }
};
```
*******************************************
这道题与[Construct Binary Tree from Inorder and Postorder Traversal](https://github.com/chenfeng123456/leetcode/blob/tree/construct_binary_tree_from_preorder_and_inorder_traverdal.mkd)思路、做法大体相同，就不再赘述了。

***稍微要注意一下的是，由于指针的参数传递也是值传递，所以这里我们在形参列表中要写成是一个指针的引用。***

另外我们自然还会想到是否可以根据先序遍历和后序遍历来还原一个二叉树，事实上这是不行的，网上有人给出了解释：

```

    1　　　　　　preorder:　　  1　　2　　3
   / \　　　　　  inorder:　　     2　　1　　3
  2   3　　  　　 postorder:　　 2　　3　　1

 

       1   　　　　preorder:　　   1　　2　　3
      / 　　　　　 inorder:　　     3　　2　　1
    2 　　　　     postorder: 　　3　　2　　1
   /
  3

 

       1　　　　    preorder:　　  1　　2　　3
      / 　　　　　  inorder:　　    2　　3　　1
     2 　　　　　　postorder:　　3　　2　　1
      \
       3

 

        1　　　　     preorder:　　  1　　2　　3
         \ 　　　　   inorder:　　    1　　3　　2
          2 　　　　 postorder:　　3　　2　　1
         /
        3

 

       1　　　　     preorder:　　  1　　2　　3
         \ 　　　　　inorder:　　    1　　2　　3
          2 　　　　 postorder:　　3　　2　　1
            \
　　　　      3

 

 从上面我们可以看出，对于先序遍历都为1 2 3的五棵二叉树，它们的中序遍历都不相同，而它们的后序遍历却有相同的，所以只有和中序遍历一起才能唯一的确定一棵二叉树。
```
- [来源](https://www.cnblogs.com/grandyang/p/4296500.html)