# Reorganize String
## Description:
```
Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.

If possible, output any possible result.  If not possible, return the empty string.
```
### Example 1:

**Input**: S = "aab"
**Output**: "aba"

### Example 2:

**Input**: S = "aaab"
**Output**: ""

### Note:

   - S will consist of lowercase letters and have length in range [1, 500].

```cpp
class Solution {
public:
    static bool compare(vector<int>& ch1,vector<int>& ch2)
    {
        return ch1[1]<ch2[1];
    }
    
    
    string reorganizeString(string S) {
        vector<vector<int>> ch(26,vector<int>(2,0));
        int len=S.length();
        char* res=new char[len+1];
        for(int i=0;i<26;i++)
        {
            ch[i][0]=i;
        }
        for(int i=0;i<S.size();i++)
            ch[S[i]-'a'][1]++;
        sort(ch.begin(),ch.end(),compare);
        int t=1;
        for(int i=0;i<26;i++)
        {
            char c='a'+ch[i][0];
            int count=ch[i][1];
            if(count>(len+1)/2) return "";
            for(;count>0;count--)
            {
                if(t>=len) t=0;
                res[t]=c;
                t+=2;
            }
        }
        res[len]='\0';
        return res;
    }
};
```
*****************************************
- 思路来源于题后的[Solution](https://leetcode.com/problems/reorganize-string/solution/)

这道题的关键思路在于如何填充字符，很容易想到对同一种字符采取隔一个填充的方法，但填充的实现方法不一样也可能会导致结果出错（比如我自己的方法）。我们这里的方法是从第二个位置、出现次数最少的字符开始填充。注意填充操作是独立于循环遍历的，故要单独设一个变量t来控制，而当t>=数组长度时，将t置为0。

我一开始还很不解万一t有多次被置为0，岂不是会覆盖掉之前的字符，后来想明白了t只会被置为0一次，因为我们是隔一个进行填充，当t从头到尾填充一次是填了数组的一半，所以第二次就直接把所有字符都填完了。