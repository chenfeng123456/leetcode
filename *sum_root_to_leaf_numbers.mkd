# 129. Sum Root to Leaf Numbers
## Description:
```
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.
```
### Note: 
A leaf is a node with no children.

### Example:
```
Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
```
### Example 2:
```
Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
```
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int pathSum;
    
    void plus(int sum,TreeNode *root)
    {   
        if(root==NULL)
        {
            return;
        }
        sum=sum*10+root->val;
        if(root->left==NULL&&root->right==NULL)
        {
            pathSum+=sum;
            return;
        }
        plus(sum,root->left);
        plus(sum,root->right);
    }
    
    
    int sumNumbers(TreeNode* root) {
        pathSum=0;
        plus(0,root);
        return pathSum;
    }
};
```
- beat 100%

一开始想着用一个栈来储存前面所有的节点，后来一想太大材小用了，我们可以直接用一个变量sum来储存到目前节点为止所表示的数的大小，再设一个类的成员变量pathSum来存放各个支路的和。用递归遍历整个二叉树，而且我们知道这里sum用值传递，当我们遍历完了当前节点一边的子树后，再遍历另一边，sum不会受影响。

注意返回的条件，这里有两种情况：一种是当前节点有一边是空的，一种是两边都是空的。对于前面一种情况，我们还不能将当前的sum加到pathSum，只需在函数的最前面加一句判断当前节点是否为空的语句，然后照常递归即可。对于后面一种情况，此时我们已经遍历完了一条支路，需要将sum加到pathSum中，然后返回，结束这条支路上的递归。