# 402. Remove K Digits
## Description:
```
Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.
```
### Note:

   1. The length of num is less than 10002 and will be ≥ k.
   2. The given num does not contain any leading zero.

### Example 1:

##### Input: num = "1432219", k = 3
##### Output: "1219"
##### Explanation: 
Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.

### Example 2:

##### Input: num = "10200", k = 1
##### Output: "200"
##### Explanation:
 Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.

### Example 3:

##### Input: 
num = "10", k = 2
##### Output: 
"0"
##### Explanation:
 Remove all the digits from the number and it is left with nothing which is 0.
```cpp
    class Solution {  
    public:  
        string removeKdigits(string num, int k) {  
            string ans;  
            int n = k, len = num.size(), cnt = 0;  
            for(auto val: num)  
            {  
                while(!ans.empty() && n > 0 && val < ans.back())  
                {  
                    n--;  
                    ans.pop_back();  
                }  
                ans.push_back(val);  
            }  
            while(ans[cnt]=='0') cnt++;  
            ans = ans.substr(cnt, len-k-cnt);  
            return !ans.size()?"0":ans;  
        }  
    };  
```
******************************************
- [思路来源](https://blog.csdn.net/qq508618087/article/details/52584133)

这道题跟之前的[Daily Temperature]()的贪心策略有点像，都是维护尽可能维护一个递增的序列，实现方式是以栈的形式。代码很简洁也很好懂，关键在于如何证明这个算法是正确可行的。

既然要让一个数最小，就要让它的高位尽可能小，由此我们分析一下这个算法的一般情况。当我们已经移除了i个元素时，换句话说，只要k>0，那么ans中的数一定是递增的，这时我们再判断当前所指的num中的数是否比ans尾部元素小，若小于，则说明用当前这个元素代替该元素会是答案更小。但如果k仍然大于0，则答案还存在可以变得更小的可能性，即移除最后一位后的ans中的尾部元素还比当前元素大，那么我们还需要接着移除。这个过程一直持续到k等于0或尾部元素小于当前元素。如果是后一种情况，前面已经说过，更具这个算法以及递推的思想，ans中的数在k还大于0时一定是递增的，因此如果尾部元素小于当前元素，那么前面的一定也小于，故循环到此就可以结束了。