# Find Duplicate Subtrees
## Description:
```
Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them.

Two trees are duplicate if they have the same structure with same node values.
```
### Example 1:
```
        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4
```
The following are two duplicate subtrees:
```
      2
     /
    4
```
and
```
    4
```
Therefore, you need to return above trees' root in the form of a list.

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    string helper(TreeNode *root, unordered_map<string, int> &m, vector<TreeNode*> &res)
    {
        if (!root)
            return "#";
        string s = to_string(root->val) + "," + helper(root->left, m, res) + "," + helper(root->right, m, res);
        if (m[s] == 1) 
            res.push_back(root);
        m[s]++;
        return s;
    }
    
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        vector<TreeNode*> res;
        unordered_map<string, int> m;
        helper(root, m, res);
        return res;
    }
};
```
*********************
- [思路来源](http://www.cnblogs.com/grandyang/p/7500082.html)

这道题如果直接对每个节点进行比较，会有大量重复计算，一定会超时。网上给出的思路是**按照一定的规则把每个节点的子树用字符串表达出来**，存放进一个unordered_map中，当且仅当这个字符串出现的次数为1时，我们才把对应的节点加入到res中，这样可以避免有多个重复子树时，会存入多个节点。

关于这里的unordered_map，网上给出的说法是它比map更适合用于查找工作。所以当遇到查找问题时，常会考虑用unordered_map。