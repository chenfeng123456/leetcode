Single Number III
====================
Description:
--------------
 Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.

For example:

Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].

Note:

    The order of the result is not important. So in the above example, [5, 3] is also correct.
    Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?




```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
       int diff=0;
        vector<int> ans(2,0);
        for(int i=0;i<nums.size();i++)
            diff^=nums[i];
        diff&=-diff;
        for(int i=0;i<nums.size();i++)
        {
            if((diff&nums[i])==0) ans[0]^=nums[i];
            else ans[1]^=nums[i];
        }
        return ans;
    }
};
```


*************************
  这道题我原本是先排序，再顺次判断nums[i]是否等于nums[i+1]。这样做虽然过了，但效率太低。于是我在网上找了找，发现一个用位运算解决的新方法。   
     
   根据位运算法则，0与任何数进行异或运算结果都为该数本身，而任何两个相同的数进行异或运算结果都为0。所以我们令0与所有元素进行异或运算，得到的值为答案中两数进行异或运算的结果。接下来我们就需要将二者区分开来。     

  由于得到的结果是由两个数进行异或运算得到的，所以结果中每一位的‘1’表示原来二者在该位上不同，取反码后则‘0’表示二者的不同位。而补码是在反码的基础上加1，这就使得反码中的第一个0变为了1。最后用补码与原码进行与运算，因为补码中上述的那个‘1’以前的位已经变为了0，而‘1’以后的为由于跟原码不同，与运算后也变为0。所以最终的结果是一个只含一个‘1’的二进制数，而这个‘1’就代表了两个数中第一个不同的位。我们将其设为diff。不难得出，diff与那两个数进行与运算运算结果一定不同且一个为0一个等于diff。这样我们就能将二者区分开来。
