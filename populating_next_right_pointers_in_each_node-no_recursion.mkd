# Populating Next Right Pointers in Each Node
## Description
```
Given a binary tree

struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.
```

### Note:

   - You may only use constant extra space.
   - Recursive approach is fine, implicit stack space does not count as extra space for this problem.
   - You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).

### Example:
```
Given the following perfect binary tree,

     1
   /  \
  2    3
 / \  / \
4  5  6  7

After calling your function, the tree should look like:

     1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \  / \
4->5->6->7 -> NULL

```
```cpp
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if (!root) return;
        TreeLinkNode *start = root, *cur = NULL;
        while (start->left) {
            cur = start;
            while (cur) {
                cur->left->next = cur->right;
                if (cur->next) cur->right->next = cur->next->left;
                cur = cur->next;
            }
            start = start->left;
        }
    }
};
```
************************************
这道题在不用递归的情况下看着有点眼熟，翻了翻以前的代码，果然之前做过一道[要求不用递归遍历二叉树的题目](https://github.com/chenfeng123456/leetcode/blob/Stack/binary_tree_preorder_traversal.mkd)
然而却对本题帮助不大，因为都要用到额外的空间。于是我上网搜了搜别人的代码，确实很巧妙，让我们来看一看别人的思路：

        对本题而言，next既是难点，有时突破点，我们不妨好好利用next这条渠道。答案中先用一个start记录每一层最左边的节点，然后让cur从最左边开始依次往右，将下一层的节点连接起来。**注意这里最重要的是当我们遍历某一层时，这一层已经在我们遍历上一层时全部连接好了**。这是因为我们其实无法直接访问到同一层的其它节点，唯一方式是通过共同的父节点，这就导致了我们采取遍历每一层时，连接的都是下一层的节点的方法。















