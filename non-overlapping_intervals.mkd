# Non-overlapping Intervals
## Description:
```
 Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

Note:

    You may assume the interval's end point is always bigger than its start point.
    Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.
```
### Example 1:

#### Input:
 [ [1,2], [2,3], [3,4], [1,3] ]

#### Output:
 1
```
Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.
```
### Example 2:

#### Input: 
[ [1,2], [1,2], [1,2] ]

#### Output:
 2

#### Explanation:
``` 
You need to remove two [1,2] to make the rest of intervals non-overlapping.
```
### Example 3:

####Input:
[ [1,2], [2,3] ]

#### Output: 
0

#### Explanation:
```
You don't need to remove any of the intervals since they're already non-overlapping.
```
```cpp
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    static bool comp(Interval &a,Interval& b)
    {
        return a.start<b.start;
    }
    
    int eraseOverlapIntervals(vector<Interval>& intervals) {
        if(intervals.size()==0||intervals.size()==1) return 0;
        sort(intervals.begin(),intervals.end(),comp);
        int end=intervals[0].end;
        int res=0;
        for(int i=1;i<intervals.size();i++)
        {
            if(intervals[i].start<end) 
            {
                res++;
                end=min(intervals[i].end,end);
            }
            else end=intervals[i].end;
            cout<<end<<endl;
        }
        return res;
    }
};
```
***************************************
对这道题我们先按start从小到大排序，再定义一个变量end用来记录在当前元素之前的区间的最右端。若当前元素的start大于等于end，则将end更新为该元素的end；否则，就要移去一个元素。由于为了区间不重叠，end应当越小越好，所以此时应当将二者中较小值赋给end，即移除end值较大的那个元素。







