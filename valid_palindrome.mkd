***my code:***
--------
```c
bool isPalindrome(char* s) {
    int size=strlen(s),i,j;
    //char *ss=NULL;
    if(size==0) return 1;
    while(1)
    {
        if(!((s[size-1]>='A'&&s[size-1]<='Z')||(s[size-1]>='a'&&s[size-1]<='z')||(s[size-1]>=48&&s[size-1]<=57)))
        {
            s[size-1]='\0';
            size--;
            if(size==0) return 1;
        }
        if((s[size-1]>='A'&&s[size-1]<='Z')||(s[size-1]>='a'&&s[size-1]<='z')||(s[size-1]>=48&&s[size-1]<=57)) break;
    }
    for(i=0,j=0;i<size;)
    {
        if(!((s[i]>='A'&&s[i]<='Z')||(s[i]>='a'&&s[i]<='z')||(s[i]>=48&&s[i]<=57))) 
        {
            for(int k=i;k<size-1;k++)
            {
                s[k]=s[k+1];
            }
            s[size-1]='\0';
            size--;
            continue;
        }
        i++;
    }
    for(i=0;i<size-1-i;i++)
    {
        if(s[i]!=s[size-1-i])
        {
            if(!((s[i]>='A'&&s[i]<='Z'||s[i]>='a'&&s[i]<='z')&&(s[size-1-i]>='A'&&s[size-1-i]<='Z'||s[size-1-i]>='a'&&s[size-1-i]<='z')))
                return 0;
            else if(abs(s[i]-s[size-1-i])!=32)
                return 0;
        }
    }
    return 1;
}
```
***nice code:***
---------
```c
bool isPalindrome(char* s) {
    int len = strlen(s);
    if(!len) return true;
    char *p1 = s, *p2 = s + len - 1;
    while(p1 < p2){
        if(!isalnum(*p1)){p1++;continue;}
        if(!isalnum(*p2)){p2--;continue;}
        if(tolower(*p1++) != tolower(*p2--)) return false;
    }
    return true;
}
```
*****************
这题做了一上午，最终以	Time Limit Exceeded告终。于是到看了以下别人的代码，确实比我的好很多，灵活使用指针的确能让代码简化不少，并且思路也清晰。   

***我的思路：***  
先判断数组是否为空，若为空，按题目要求返回1。接着再从最后一个开始检查是否为数字或字母，若是则置为空字符，并且size相应的减少1，然后循环回来继续检查，直到最后一个变为数字或字母为止。接下来再从头开始，依次检查每个元素是否为数字或字母，若不是则将其删掉，即将后面的每个元素往前移一位，并将原来的最后一位置为空字符，size减一。
