# Construct String from Binary Tree
## Description:
```
You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.

The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.
```
### Example 1:
```
Input: Binary tree: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

Output: "1(2(4))(3)"

Explanation: Originallay it needs to be "1(2(4)())(3()())", 
but you need to omit all the unnecessary empty parenthesis pairs. 
And it will be "1(2(4))(3)".
```
 
### Example 2:
```
Input: Binary tree: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

Output: "1(2()(4))(3)"

Explanation: Almost the same as the first example, 
except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
```
 


```python
class Solution:
    s = ""
    def construct(self, t):
        if t is not None:
            self.s += str(t.val)
            if t.left is not None or t.right is not None:
                self.s += '('
                self.construct(t.left)
                self.s += ')'
                if t.right is not None:
                    self.s += '('
                    self.construct(t.right)
                    self.s += ')'

    
    def tree2str(self, t):
        """
        :type t: TreeNode
        :rtype: str
        """

        self.construct(t)
        return self.s

```
***********************************
这道题主要卡在了python的语法上。在python不光调用函数时前面要加self，调用类变量也要加。

主要是卡在了类变量的定义和调用上,另外就是对情况的考虑想复杂了。其实只要左右子树中有一个非空，那么左子树一定会占用一个括号；只有当左子树非空且右子树为空时，我们才省略不写。